Тестируемая веб-страница предлагает посетителю пройти небольшой тест на знания о http-запросах и умения по их перехвату/ подмене.

Изначально предполагается, что посетитель будет пользоваться "снифферами", однако вручную я выполнил этот тест используя только браузерный DevTools.

Создание первого автотеста для портфолио показало мне мои недостаточные знания по использованию CodeceptJS для иммитации запросов к серверу.
Именно поэтому своей второй работой для портфолио я решил выбрать веб-страницу http://task.test.ivi.ru.

Для каждой части теста в самом js-файле предусмотрено краткое описание производимых в ней действий. Также мной закомментированы многие
производимые действия, потому данное описание, скорее всего, будет во многом повторять уже написанное мной в комментариях к тесту.

Итак, теперь по порядку:
1. Первая часть теста предлагает нам ввести в поля "Логин" и "Пароль" некие неизвестные нам валидные значения для логина и пароля.
Когда мы вводим любое сочетание случайных значений логина и пароля мы получаем красный текст с ошибкой и подсказкой о том,
что нам надо делать дальше.

Потому первым делом автотест вводит слова "Login" в поле "Логин" и "Password" в поле "Пароль".
Изначально я думал отказаться от этого шага, однако ввёл его для наглядности и автоматической проверки того, что сайт не начнёт,
с какой-то стати, принимать любой логин и пароль. Возможно в будущем стоит "прикрутить" случайную генерацию для первых значений 
логина и пароля.

Вводом логина и пароля с дальнейшим прожатием кнопки "вход" занимается функция "fieldFilling".

Затем автотест проверяет, что мы получили ошибку. Изначально я планировал просто проверить наличие слов "Логин и/или пароль введены неверно",
но немного поразмыслив и осознав, что текст ошибки в какой-нибудь прекрасный день может измениться - решил выполнить проверку именно на красный 
текст. Текст ошибки выдаётся в теге <p>, обладающем атрибутом " style='color: red;' ". Изменять саму архитектуру веб-страницы автор будет с 
меньшей вероятностью, потому я выполняю проверку на поиск элемента с красным цветом в стиле: 'I.seeElement('[style*="red"]')'.

Затем я подготавливаю заголовки и тело для POST-запроса, и отправляю запрос на сервер. Запрос обязан содержать id-сессии в заголовке и 
значение csrf-токена в теле запроса. Если всё выполнено верно - получаем среди заголовков ответа сервера ключ "login-and-password" со значением
"curl /get_login to get your login and password".

При работе "вручную" эта операция куда проще - после ввода невалидных данных мы просто открываем DevTools, проверяем вкладку "Network", находим 
POST-запрос и в заголовке ответа сервера сразу же видим заветный заголовок с дальнейшей инструкцией.
С автотестом всё намного сложнее, отчего во много крат интереснее. 

Получив дальнейшую инструкция я отсекаю необходимую нам часть строки ("/get_login") и открываю новую вкладку по адресу http://task.test.ivi.ru/get_login
На ней мы видим объект data с двумя ключами "login" и "password". Отсекаем всё лишнее, переопределяем переменные "login" и "pass", 
придавая им валидные значения логина и пароля и закрываем вкладку.

Нам остаётся лишь простая операция ввода валидных значений логина и пароля в соответствующие поля и нажатие кнопки "вход".
Повторно тспользуем функцию "fieldFilling" и переходим ко второй части теста.

2. Вторая часть теста заключается в том, что нам задают вопрос "Вы хотите работать в ivi?", но варианта ответа "да" не предусмотрено.
Первым делом с помощью простейшей функции для получения случайного числа выбираем один из чекбоков и нажимаем кнопку "выполнить задание".
Убеждаемся, что выбранный чекбокс привёл к получению ошибки с инструкцией "Подмени запрос, чтобы отправилось 'да'".
Отсекаем от текста ошибки слово заключённое в кавычки для дальнейшего использования в теле запроса.

Редактируем переменную хранящую тело запроса и отправляем на сервер новый POST-запрос. В ответ на корректный POST-запрос получаем новую html-страницу. 
Перейти на неё напрямую у меня не выходило, получить значение её url напрямую из ответа серевра не вышло, но сам код страницы хранит в себе
необходимую часть нового url-а, потому мы извлекаем её напрямую из кода html-документа, переходим на новую страницу и, соответственно, к финальной части теста.

К слову, в комментарии ко второй части я утверждаю, что есть второй, более простой, способ выполнить вторую часть теста - изменить сам HTML-код
страницы. Этот способ также рабочий и в конце документа "IVI_Sniffer_test.js" можно обнаружить функцию, которая не вызывается на протяжении
автотеста - attrChanger(). Эта функция вызывает другую стрелочную функцию, которая с помощью "чистого" JavaScript изменяет значение одного из
вариантов радиоменю (меняет отправыляемое значение и текстовый контекст радиокнопки), а затем глобальный объект "I" выбирает изменённый чекбокс и
прожимает кнопку "выполнить задание". Функция проверена на работоспособность, но во время автотеста не используется.

3. На третьей странице тестируемого веб-сайта нам предлагают найти в объекте json массив в платформами, на которых доступен некий контент.
Здесь всё довольно просто, никаких запросов и анализа трафика. Сразу же предполагаем, что в нынешние времена сложно найти контент, который будет
недоступен на iOS и Android (или хотя бы на одной из этих платформ). Следовательно с поисковыми "запросами" мы определились

Я объявляю переменную, которая будет хранить весь наш объект json и выполняю поиск позиций слов 'ios', 'iOS', 'iOs', 'android', 'Android'.
Если найдено хоть одно совпадение - работаю с его позицией. Если найдено 2 совпадения - работаю с наименьшей позицией (то бишь со словом, найденным первее).

Далее я захватываю часть нашего объекта, используя полученные позиции ключевых слов, использую функцию для получения длины массива доступных для
контента платформ и размер массива ввожу в специально предназначенное для него поле. Жмём кнопку "Получить код" и переходим к простенькому финалу.

4. На данной странице мы видим уведомление, что задание успешно выполнено и мы получили некий код.
Первым делом я проверяю, что я действительно попал на страницу с заголовком "Готово!". Вот только этого недостаточно. При вводе неверного числа, 
соответствующего размеру массива доступных платформ, мы тоже попадём на страницу "Готово!". UI или UX баг на лицо. Добавим очередную проверку 
теперь уже на отсутствие всё того же красного текста об ошибке.

Итак, проверки на заголовок веб-страницы и отсутствие красного текста на нём пройдены. Код выделен жирным шрифтом, что позволяет нам успешно 
отделить его от остального текста, сделать по нему двойной клик и иммитацией нажатия комбинации клавиш "Ctrl+C" отправить его в буфер обмена.
Далее дело необязательное, но приятное и в какой-то степени полезное - вывожу в терминал информацию: сам код и уведомления о том, что он скопирован
в буфер обмена и тест успешно завершён.

К данному тесту также прилагаю отснятое мной видео прохождения теста в "window mode" режиме.
На видео видно, как в результате автоматизации теста успешно проходятся все этапы и по его завершению мы получаем желаемый результат - страницу с кодом,
а фреймворк CodeceptJS собщает нам, что тест пройден. 

В конце видео отчётливо видно, что тест заканчивается со статусом "OK" за 11 секунд. В Headless режиме время прохождения теста также равно 11 секундам.